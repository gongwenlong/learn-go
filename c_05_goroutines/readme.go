package main

//一个应用程序是运行在机器上的一个进程；进程是一个运行在自己内存地址空间里的独立执行体。
// 一个进程由一个或多个操作系统线程组成，这些线程其实是共享同一个内存地址空间的一起工作的执行体。
// 几乎所有’正式’的程序都是多线程的，以便让用户或计算机不必等待，或者能够同时服务多个请求（如 Web 服务器），
// 或增加性能和吞吐量（例如，通过对不同的数据集并行执行代码）。
// 一个并发程序可以在一个处理器或者内核上使用多个线程来执行任务，
// 但是只有同一个程序在某个时间点同时运行在多核或者多处理器上才是真正的并行。
//
//并行是一种通过使用多处理器以提高速度的能力。所以并发程序可以是并行的，也可以不是。
//
//公认的，使用多线程的应用难以做到准确，最主要的问题是内存中的数据共享，
// 它们会被多线程以无法预知的方式进行操作，导致一些无法重现或者随机的结果（称作 竞态）。
//

//不要使用全局变量或者共享内存，它们会给你的代码在并发运算的时候带来危险。


//解决之道在于同步不同的线程，对数据加锁，这样同时就只有一个线程可以变更数据。
// 在 Go 的标准库 sync 中有一些工具用来在低级别的代码中实现加锁；
// 不过过去的软件开发经验告诉我们这会带来更高的复杂度，更容易使代码出错以及更低的性能，
// 所以这个经典的方法明显不再适合现代多核 / 多处理器编程：thread-per-connection 模型不够有效。
//
//Go 更倾向于其他的方式，在诸多比较合适的范式中，
// 有个被称作 Communicating Sequential Processes（顺序通信处理）（CSP, C. Hoare 发明的）
// 还有一个叫做 message passing-model（消息传递）（已经运用在了其他语言中，比如 Erlang）。
//
//在 Go 中，应用程序并发处理的部分被称作 goroutines（协程），
// 它可以进行更有效的并发运算。在协程和操作系统线程之间并无一对一的关系：
// 协程是根据一个或多个线程的可用性，映射（多路复用，执行于）在他们之上的；
// 协程调度器 在 Go 运行时很好的完成了这个工作。
//
// 协程工作在相同的地址空间中，所以共享内存的方式一定是同步的；这个可以使用 sync 包来实现
// ，不过我们很不鼓励这样做：Go 使用 channels 来同步协程）
//

// 当系统调用（比如等待 I/O）阻塞协程时，其他协程会继续在其他线程上工作。
// 协程的设计隐藏了许多线程创建和管理方面的复杂工作。
//
// 协程是轻量的，比线程更轻。它们痕迹非常不明显（使用少量的内存和资源）：
// 使用 4K 的栈内存就可以在堆中创建它们。因为创建非常廉价，
// 必要的时候可以轻松创建并运行大量的协程（在同一个地址空间中 100,000 个连续的协程）。
// 并且它们对栈进行了分割，从而动态的增加（或缩减）内存的使用；
// 栈的管理是自动的，但不是由垃圾回收器管理的，而是在协程退出后自动释放。


//协程可以运行在多个操作系统线程之间，也可以运行在线程之内，
// 让你可以很小的内存占用就可以处理大量的任务。由于操作系统线程上的协程时间片，
// 你可以使用少量的操作系统线程就能拥有任意多个提供服务的协程
// ，而且 Go 运行时可以聪明的意识到哪些协程被阻塞了，
// 暂时搁置它们并处理其他协程。
//
// 存在两种并发方式：确定性的（明确定义排序）和非确定性的（加锁 / 互斥从而未定义排序）。
// Go 的协程和通道理所当然的支持确定性的并发方式（例如通道具有一个 sender 和一个 receiver）。
// 我们会使用一个常见的算法问题（工人问题）来对比两种处理方式。
//
// 协程是通过使用关键字 go 调用（或执行）一个函数或者方法来实现的（也可以是匿名或者 lambda 函数）。
// 这样会在当前的计算过程中开始一个同时进行的函数，在相同的地址空间中并且分配了独立的栈，
// 比如：go sum(bigArray)，在后台计算总和。
//

// 协程的栈会根据需要进行伸缩，不会出现栈溢出；开发者无需关心栈的大小。
// 当协程结束的时候，它会静默退出：用来启动这个协程的函数也不会得到任何的返回值。
//
//任何 Go 程序都必须有的 main() 函数也可以看做是一个协程，
// 尽管它并没有通过 go 来启动。协程可以在程序初始化的过程中运行（在 init() 函数中）。
//
//在一个协程中，比如它需要进行非常密集的运算，你可以在运算循环中周期的使用 runtime.Gosched()：
// 这会让出处理器，允许运行其他协程；它并不会使当前协程挂起，所以它会自动恢复执行。使用 Gosched() 可以使计算均匀分布，
// 使通信不至于迟迟得不到响应。










// ---------- 并发和并行的差异

// Go 的并发原语提供了良好的并发设计基础：表达程序结构以便表示独立地执行的动作；所以 Go 的重点不在于并行的首要位置：并发程序可能是并行的，也可能不是。并行是一种通过使用多处理器以提高速度的能力。但往往是，一个设计良好的并发程序在并行方面的表现也非常出色。
//
//在当前的运行时（2012 年一月）实现中，Go 默认没有并行指令，只有一个独立的核心或处理器被专门用于 Go 程序，不论它启动了多少个协程；所以这些协程是并发运行的，但他们不是并行运行的：同一时间只有一个协程会处在运行状态。
//
//这个情况在以后可能会发生改变，不过届时，为了使你的程序可以使用多个核心运行，这时协程就真正的是并行运行了，你必须使用 GOMAXPROCS 变量。
//
//这会告诉运行时有多少个协程同时执行。
//
//并且只有 gc 编译器真正实现了协程，适当的把协程映射到操作系统线程。使用 gccgo 编译器，会为每一个协程创建操作系统线程。
